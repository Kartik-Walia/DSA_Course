Graph is a type of a non-linear data structure which is combination of nodes and edges
Node : entity to store data
Edges : for connecting nodes 
Path : Sequence of nodes you're travelling in which each node comes exactly once 




TYPES OF GRAPH 
1. Undirected Graph 
    Can go from U to V as well as V to U
    Represented using lines
    Degree : Degree of a vertex is given by no. of edges connected to it 
2. Directed Graph
    Can go only from 1 way either U to V or V to U
    Represented using line with arrows
    Indegree : Indegree of a vertex is given by no. of edges coming towards the vertex 
    Outdegree : Outdegree of a vertex is given by no. of edges going away from the vertex 




WEIGHTED GRAPH 
Graphs having wieghts over it's edges 
1. Weighted Undirected Graph : If no weights given, assume weights as 1 on each edge 
2. Weighted Directed Graph : If no weights given, assume wieghts as 1 on each edge 




CYCLIC GRAPH 
If in graph, you're able to create a path which allow you to reach to an already travelled node again, then such graph is called Cyclic Graph 




ACYCLIC GRAPH 
If in graph, you're unable to create a path which allows you to reach to an already travelled node again, then such graph is called Acyclic Graph 




GRAPH REPRESENTATION 
input -> (no. of nodes, no. of edges & edges list)
1. Adjacency Matrix 
    Create a 2D adjacency matrix 
    Where index represents nodes 
    At places nodes connected, put 1
    At places nodes are not connected, put 0

    Space Compexity : O(n^2), where n represents no. of nodes 
    Do this using 2 for loops
2. Adjacency List 
    List Nodes -> tells what connection are available 
    Ek entity ke corresponding uske saare neighbours hain 
    Since 2nd entity mei bhot saare neighbours aa skte hain, toh voh ek list hogi & 1st entity is single object
    It can be implemented using map 
    Eg : 0 -> 1, 4 can be implemented as map< int , list<int> >;




DISCONNECTED GRAPH 
Graph having 2 or more components out of which atleast 1 set is disconnected 
  0
  |\
  | 3    2
  |/
  1




BFS TRAVERSAL (BREADTH FIRST SEARCH)
In this traversal algorithm, 1 node is selected & then, all of the adjacent nodes are visited one by one.

  0
    \
     \
  4---2           print -> 0, 2, 3, 4
   \ /
    3

  0
  | \
  \  \
   \  3 --- 1       print -> 0, 2, 3, 4, 1
    \       |
      2 --- 4

Implementation :
1. Data structure which tracks that whether a particular node is visited or not, all false initially no node visited
    unordered_map < node, bool >;
2. We need 1 more data structure queue (FIFO) in which i am gonna put all nodes and after pushing each node, gonna process it's neighbours 

  0 --- 3     2         adjacency list              visited DS (All false initially no node visited)
         \   /          0 -> 3                      0 -> F
          \ /           1 -> 2, 3, 4                1 -> F
        4--1            2 -> 1                      2 -> F
                        3 -> 0, 1                   3 -> F
                        4 -> 1                      4 -> F

OUTPUT : 0 3 1 2 4

If node isn't visited call BFS function (do this inside loop which goes till n), this is done to make sure Disconnected Graph is also covered
Step-1 : Push sourceNode in queue 
Step-2 : From queue save entry as firstNode
Step-3 : Remove it from queue
Step-4 : Mark it True in unordered_map (visited)
Step-5 : Print it in Answer
Step-6 : Push all neighbours of firstNode in queue & mark them visited (Make sure you can't push neighbour if it's True)
Step-7 : Recursively do all steps fromt Step-2 to Step-6

Time & Space Complexity : O(N+E), where N -> no. of vertices & E -> no. of edges




DEPTH TRAVERSAL (DEPTH FIRST SEARCH)
In this traversal algorithm, starting from a node, the algorithm explores as far as possible along each branch before backtracking.

  0 --- 4 --- 2
        |     |
        1     |       print -> 0, 4, 2, 3, 5, 1
        |     |
        5 --- 3

Implementation :
1. Data structure which tracks that whether a particular node is visited or not, all false initially no node visited
    unordered_map < node, bool >;

  0 --- 2 --- 1         adjacency list              visited DS (All false initially no node visited)
        |     |         0 -> 2                      0 -> F
        |     |         1 -> 2, 3                   1 -> F
        4 --- 3         2 -> 0, 1, 4                2 -> F
                        3 -> 1, 4                   3 -> F
                        4 -> 2, 3                   4 -> F

print -> 0, 2, 1, 3, 4

dfs(0) -> dfs(2) -> dfs(1) -> dfs(3) -> dfs(4) now backtracking goes on  until we reach dfs(0)
print -> 0, 2, 1, 3, 4

If node isn't visited call DFS function (do this inside loop which goes till n), this is done to make sure Disconnected Graph is also covered

Time & Space Complexity : Linear




CYCLE DETECION IN UNDIRECTED GRAPH VIA BFS
Let's consider undirected disconnected graph 
  1 -- 2          4 -- 5 -- 6
       |               |    |                 Yes, cycle detected
       3               7 -- 8 -- 9

Implementation :
1. Data structure which tracks that whether a particular node is visited or not, all false initially no node visited
    unordered_map < node, bool >;
2. We need 1 more data structure queue (FIFO) in which i am gonna put all nodes and after pushing each node, gonna process it's neighbours 
3. 1 data structure for parent in form x->y i.e. y is parent of x
4. Adjacency list 

Step-1 : Push sourceNode in queue 
Step-2 : From queue save entry as firstNode 
Step-3 : Remove it from queue
Step-4 : Mark it True in unordered_map (visited)
Step-5 : Push all neighbours of firstNode in queue (Make sure you can't push neighbour if it's True && it's parent of firstNode)
Step-6 : Recursively do all steps fromt Step-2 to Step-6
Step-7 : If you find a case when neighbour of firstNode is True but it's not parent of firstNode, Cycle is detected

In short, it would be completely same as BFS code, just 1 data structure of parent would be added along with the if condition talked above 

Time & Space Complexity (same as BFS) : O(N+E), where N -> no. of vertices & E -> no. of edges




CYCLE DETECION IN UNDIRECTED GRAPH VIA DFS
Let's consider undirected disconnected graph 
  1 -- 2          4 -- 5 -- 6
       |               |    |                 Yes, cycle detected
       3               7 -- 8 -- 9

Implementation :
1. Data structure which tracks that whether a particular node is visited or not, all false initially no node visited
    unordered_map < node, bool >;

If you find a case when neighbour of firstNode is True but it's not parent of firstNode, Cycle is detected

In short, it would be completely same as DFS code, just 1 data structure of parent would be added along with the if condition talked above 




CYCLE DETECTION IN DIRECTED GRAPH VIA DFS 
Adjacency List 
  1 -> 2
  2 -> 3, 4
  3 -> 7, 8
  4 -> 5                  Yes, cycle detected (4 5 6)
  5 -> 6
  6 -> 4
  7 -> 
  8 -> 7
It would be similar to the case for undirected, but we would need 1 more data structure (array or map) dfsVisited, which keeps track of which nodes have been called, returned call or haven't been called, along with this we need 1 more if condition 
If a node has been called, it's dfsVisited would be 1
If a node returned call, it's dfsVisited would be 0 again

If for a node, neighbour is visited & also it's dfsVisited is true, then cycle is present in directed graph 




TOPOLOGICAL SORT
It can be only applied to DAG (Directed Acyclic Graph)

Topological sort is a linear ordering of vertices such that for every directed edge from vertex 'u' to 'v', vertex 'u' always comes before 'v' in the ordering. Topological sort is not possible if graph is not a DAG
Multiple ordering can exist which satisfies above condition

Example
  Adjacency List
  0 -> 1, 3
  1 -> 2                      0 1 3 2 -> Valid TS 
  2 ->                        3 2 1 0 -> Invalid TS (0 should come before 1 in TS)
  3 -> 2

Why we cannot apply TS on directed cyclic graph ?
  Adjacency List
  1 -> 2
  2 -> 3
  3 -> 1
Now if you check 1 should appear before 2, 2 should appear before 3 and 3 should appear before 2 in linear ordering 
All 3 condiitons cannot be satisfied simultaneously, hence we cannot apply TS to an directed cyclic graph

This can be used in cycle detection of directed graph also, as if we are unable to find topological sort of a directed graph, then the graph would contain a cycle 


TOPOLOGICAL SORT USING DFS 
Implementation :
1 Data structure for visited nodes
1 Data structure (stack) for 
1 Data structure for adjacency list
Whenever you go back from a call (node returns a call), you push that node in the stack 

Adjacency List 
1 -> 2, 3
2 -> 4
3 -> 4
4 -> 5, 6
5 -> 6
6 ->

dfs(1) -> dfs(2) -> dfs(4) -> dfs(5) -> dfs(6)
then 6 returns call so push 6 into stack 
then 5 returns call so push 5 into stack (as 6 is visited)
then 4 returns call so push 4 into stack (as 5, 6 are visited)
then 2 returns call so push 2 into stack (4 is viisted)
then dfs(1) -> dfs(3) (as 3 is not visited)
then 3 returns call so push 3 into stack (4 is visited)
then 1 returns call so push 1 into stack (2, 3 are visited)

Order in stack(LIFO) from top would be 1, 3, 2, 4, 5, 6 which is a valid topological sort 

Why stack is needed ?
When we're unable to go further from any recursive function call, means we only have choice to back track, then we're putting that node in stack and stack has property of LIFO. So, in short we've putted such a node in stack which can't be propogated further, we've putted in stack so taht it comes out at last

Time Complexity : O(N+E) which is linear 
Space Complexity : Linear ( O(N) + O(N) + O(N) )      (visited + stack + recursive)


TOPOLOGICAL SORT USING BFS (Kahn's algorithm)
Adjacency List
1 -> 2, 3
2 -> 5
3 -> 5       Output: 1 2 3 5 4
5 -> 4

Implementation :
1. Make a data structure for storing indegree of each node 
    |0|1|1|1|2|           -> Indegree
     1 2 3 4 5            -> Nodes


Step-1 : Find indegree of all nodes 
Step-2 : Make a queue and insert all nodes having indegree 0
Step-3 : Do BFS with some small changes 
        a. Get front Node 
        b. pop from the queue  
        c. add front Node to the answer
        d. Get neighbours of front Node (considering above example when 1 is removed indegree of 2 & 3 reduces by 1, so indegree of 2 & 3     will become 0), so we can say when front Node is removed, then indegree of it's neighbours would be reduced by 1
Step-4 : Repeat Step-2 & Step-3

Time & Space Complexity : O(N+E), where N -> no. of vertices & E -> no. of edges




CYCLE DETECTION IN DIRECTED GRAPH VIA BFS 
If we're able to find topological sort of directed graph, then it's a directed acyclic graph 
But if we're unable to find valid topological sort of directed graph, then it must be cyclic graph 

In short, just making minute chnages & reusing Kahn's Algorithm 

Time & Space Complexity : O(N+E), where N -> no. of vertices & E -> no. of edges




SHORTEST PATH IN UNDIRECTED GRAPH VIA BFS 
Step-1 : Create a parent data structure using BFS 
Step-2 : Back Track from Destination node to Source node & store it in answer simultaneously
Step-3 : Reverse the answer to obtain the final corrected answer 

    2 --- 5
   /       \
  1 -- 3 -- 8           Start Node = 1 
   \       /            Destination Node = 8
    4 -6- 7             Shortest Path = 1 -> 3 -> 8

Time & Space Complexity : O(N+E), where N -> no. of vertices & E -> no. of edges




