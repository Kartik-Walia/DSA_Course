Graph is a type of a data structure which is combination of nodes and edges
Node : entity to store data
Edges : for connecting nodes 
Path : Sequence of nodes you're travelling in which each node comes exactly once 


TYPES OF GRAPH 
1. Undirected Graph 
    Can go from U to V as well as V to U
    Represented using lines
    Degree : Degree of a vertex is given by no. of edges connected to it 
2. Directed Graph
    Can go only from 1 way either U to V or V to U
    Represented using line with arrows
    Indegree : Indegree of a vertex is given by no. of edges coming towards the vertex 
    Outdegree : Outdegree of a vertex is given by no. of edges going away from the vertex 


WEIGHTED GRAPH 
Graphs having wieghts over it's edges 
1. Weighted Undirected Graph : If no weights given, assume weights as 1 on each edge 
2. Weighted Directed Graph : If no weights given, assume wieghts as 1 on each edge 


CYCLIC GRAPH 
If in a graph, you're able to create a path which allow you to reach to an already travelled node again, then such a graph is called Cyclic Graph 


ACYCLIC GRAPH 
If in a graph, you're unable to create a path which allows you to reach to an already travelled node again, then such a graph is called Acyclic Graph 


GRAPH REPRESENTATION 
input -> (no. of nodes, no. of edges & edges list)
1. Adjacency Matrix 
    Create a 2D adjacency matrix 
    Where index represents nodes 
    At places nodes connected, put 1
    At places nodes are not connected, put 0

    Space Compexity : O(n^2), where n represents no. of nodes 
    Do this using 2 for loops
2. Adjacency List 
    List Nodes -> tells what connection are available 
    Ek entity ke corresponding uske saare neighbours hain 
    Since 2nd entity mei bhot saare neighbours aa skte hain, toh voh ek list hogi & 1st entity is single object
    It can be implemented using map 
    Eg : 0 -> 1, 4 can be implemented as map< int , list<int> >;


DISCONNECTED GRAPH 
Graph having 2 or more components out of which atleast 1 set is disconnected 
  0
  |\
  | 3    2
  |/
  1


BFS TRAVERSAL (BREADTH FIRST SEARCH)
In this traversal algorithm, 1 node is selected & then, all of the adjacent nodes are visited one by one.

  0
    \
     \
  4---2           print -> 0, 2, 3, 4
   \ /
    3

  0
  | \
  \  \
   \  3 --- 1       print -> 0, 2, 3, 4, 1
    \       |
      2 --- 4

Implementation :
1. Data structure which tracks that whether a particular node is visited or not, all false initially no node visited
    unordered_map < node, bool >;
2. We need 1 more data structure queue (FIFO) in which i am gonna put all nodes and after pushing each node, gonna process it's neighbours 

  0 --- 3     2         adjacency list              visited DS (All false initially no node visited)
         \   /          0 -> 3                      0 -> F
          \ /           1 -> 2, 3, 4                1 -> F
        4--1            2 -> 1                      2 -> F
                        3 -> 0, 1                   3 -> F
                        4 -> 1                      4 -> F

OUTPUT : 0 3 1 2 4

If node isn't visited call BFS function (do this inside loop which goes till n), this is done to make sure Disconnected Graph is also covered
Step-1 : Push sourceNode in queue 
Step-2 : From queue save entry as firstNode, 
Step-3 : Remove it from queue
Step-4 : Mark it True in unordered_map (visited)
Step-5 : Print it in Answer
Step-6 : Push all neighbours of firstNode in queue (Make sure you can't push neighbour if it's True)
Step-7 : Recursively do all steps fromt Step-2 to Step-6

Time & Space Complexity : O(N+E), where N -> no. of vertices & E -> no. of edges


DEPTH TRAVERSAL (DEPTH FIRST SEARCH)
In this traversal algorithm, starting from a node, the algorithm explores as far as possible along each branch before backtracking.

  0 --- 4 --- 2
        |     |
        1     |       print -> 0, 4, 2, 3, 5, 1
        |     |
        5 --- 3

Implementation :
1. Data structure which tracks that whether a particular node is visited or not, all false initially no node visited
    unordered_map < node, bool >;

  0 --- 2 --- 1         adjacency list              visited DS (All false initially no node visited)
        |     |         0 -> 2                      0 -> F
        |     |         1 -> 2, 3                   1 -> F
        4 --- 3         2 -> 0, 1, 4                2 -> F
                        3 -> 1, 4                   3 -> F
                        4 -> 2, 3                   4 -> F

print -> 0, 2, 1, 3, 4

dfs(0) -> dfs(2) -> dfs(1) -> dfs(3) -> dfs(4) now backtracking goes on  until we reach dfs(0)
print -> 0, 2, 1, 3, 4

If node isn't visited call DFS function (do this inside loop which goes till n), this is done to make sure Disconnected Graph is also covered

Time & Space Complexity : Linear